=======================================================================
假设现在有一个原始的训练数据集（用户物品评分矩阵）:
u1,p1,5
u1,p2,3
u1,p3,5
u1,p4,1
u1,p8,2
u1,p9,1
u1,p6,3

u2,p1,4
u2,p12,3
u2,p13,5
u2,p41,1
u2,p8,2
u2,p9,1
u2,p16,3
u2,p28,2
u2,p29,1
u2,p26,3

u3,p11,5
u3,p22,3
u3,p3,5
u3,p14,1
一、计算所有用户与用户的相似度
	1.1、计算u1和u2的相似度
		- 从评分矩阵中提取u1和u2共同评分的商品评分
			u1: [p1:5, p8:2, p9:1] --> [5,2,1]
			u2: [p1:4, p8:2, p9:1] --> [4,2,1]
		- 计算这两个向量的相似度直接作为用户的相似度s12
			NOTE：自己补全(余弦相似度或者欧几里得距离)
	1.2、计算u1和u3的相似度
		- 从评分矩阵中提取u1和u3共同评分的商品评分
			u1: [p3:5] --> [5]
			u3: [p3:5] --> [5]
		- 计算这两个向量的相似度直接作为用户的相似度s13
			NOTE：自己补全(余弦相似度或者欧几里得距离)
	1.3、计算u2和u3的相似度
		- 从评分矩阵中提取u2和u3共同评分的商品评分
			u2: [] --> []
			u3: [] --> []
		- 计算这两个向量的相似度直接作为用户的相似度s23(直接就是0)
			NOTE：自己补全(余弦相似度或者欧几里得距离)

二、计算用户对物品的评分(两层循环的结果，自己补全)
	2.1 计算u3对商品p1的评分
		- 提取和u3相似的用户K个(eg: 1个，要求这个用户在商品p1上是有评分的)
			基于相似度矩阵发现最相似度的是u1
			u1 -> p1 -> 5
		- 将所有相似用户在商品p1上的评分合并
			最简单的合并: 均值合并(r1+r2+..+rk)/k
			k==1 --> 预测评分等于5
=======================================================================
作业：
    -1. 使用UserCF和ItemCF将每个用户的推荐列表保存到文件中
        userid1: pid1:score1, pid2:score2, pid3:score3, pid4:score4
        userid2: pid9:score1, pid7:score2, pid3:score3, pid2:score4
        ......
    -2. 使用ItemCF将相似物体列表保存到文件中:
        pid1: pid7:0.67, pid23:0.56, pid145:0.34
        pid2: pid4:0.34
        .....
    -3. 任意弄一个二分类的数据/基于sklearn随机一个二分类的数据
        基于PyTorch框架实现以下logistic回归模型
=======================================================================
关联规则的应用：
    看了又看功能基于关联规则的实现：
        -1. 训练/挖掘：
            -a. 将一个会话中用户的所有浏览商品作为一个商品列表，也就是交易
            -b. 利用关联规则的算法挖掘频繁1项集和频繁2项集
            -c. 计算所有商品X->Y的置信度
                pids = [1,2,3,4,5,6,7]
                for pidi in pids:
                    s1 = xxx # 获取pidi单独出现的支持度
                    if s1 is None:
                        continue
                    for pidj in pids:
                        if pidi == pidj:
                            continue
                        s2 = xxxx # 获取pidi和pidj同时出现的支持度
                        if s2 is None:
                            continue
                        c = s2 / s1  # 置信度
                        # 将pidi、pidj、c保存到数据库/文件
                        # 或者处理后保存: 只包括pidi对应的置信度最高的前100个pidj
        -2. 推理/线上应用：
            -a. 当用户浏览当前商品的时候，直接基于当前商品id从数据库中获取置信度最高的前N个作为推荐
=======================================================================








